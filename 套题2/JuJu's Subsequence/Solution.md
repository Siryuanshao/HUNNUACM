https://leetcode-cn.com/problems/sum-of-subsequence-widths/solution/zi-xu-lie-kuan-du-zhi-he-by-leetcode

力扣891,数学,简单题



因为对于每一个非空子序列，只用关注其中的最大元素和最小元素，与序列的顺序无关，所以我们可以先对数组进行排序，方便处理。

用 (i, j) 表示固定两端的序列，它的最小值为 a[i]，最大值为 a[j]，这样的序列有 2 ^ j - i - 1 个。每个序列的宽度为 a[j] - a[i]，这一组序列的总宽度为 (a[j] - a[i]) * (2 ^ j - i - 1)。此时可以在 O(n^2) 的时间复杂度内解决问题。但是数据范围达到了 20000， O(n^2) 的算法不可取。要想办法降低时间复杂度。

对于以 a[j] 结尾的序列，它的总宽度为：

result = (a[j] - a[0]) * (2 ^ j - 1) + (a[j] - a[1]) * (2 ^ j - 2) + ... + (a[j] - a[j - 1]) * (2 ^ 0)。

可表示为 result = X - Y，其中

X = a[j] * (2 ^ j - 1 + 2 ^ j - 2 + ... + 2 ^ 0) = a[j] * ((2 ^ j) - 1)。

Y = a[0] * 2 ^ j - 1 + a[1] * 2 ^ j - 2 + ... + a[j - 1] * 2 ^ 0。

X 可以在常量时间内得到，Y 不行，但是可以知道 Y[j + 1] = Y[j] * 2 + a[j]。有了这个递推表达式，每个 Y 也可以在遍历过程中常数时间得到。

在计算过程中 res 可能为负，为了保证得到正确的结果，最后进行一次 (res + MOD) % MOD 这个操作，保证结果为正。

算法时间复杂度为 O(nlogn)，主要花费在排序上，排序完成后只需要 O(n) 的扫描。
